ANGULAR INSTALLATION
If using nvm - nvm install [majorVersionNumber] - This will install the latest version of the defined major version
Using npm - `npm install -g @angular/cli` for installing the latest version. For a specific versio add `@<versionNumber>` after the `cli`

// Creating aa new Angular project: `ng new <project-name>`

// Running angular application on HTTPS
1) Go to mkcert on GitHub (https://github.com/FiloSottile/mkcert) and follow the installation instructions. To install on Mac run `brew install mkcert`
2) then, run -> `mkcert -install` to create a new local certificate. If there is a trusted certificate already a message will be displayed - "The local CA is already installed in the system trust store! üëç"
3) Create a valid certificate for the desired domain. For example, for localhost run `mkcert localhost` (might require sudo permissions)
4) Configure angular to use the certificate in the angular.json file - under the serve section, below the [builder] key add: `"options": {`
  `"ssl": true,`
  `sslCert": "ssl/localhost.pem",` // The location must match the file location (here it is under the <ssl> folder)
  `"sslKey": "ssl/localhost-key.pem"`
`},` (without the tic (`) ofcourse)

In order to enable HTTP requests in angular we need first to add the HTTP Client in the app.config.ts file in the app folder under the src folder -> add `provideHttpClient()` to the providers array. Thiswill enable the ability to inject it to the angular components

////// Getting an ERR_CERT_AUTHORITY_INVALID error in the http response ////////////
The [NET::ERR_CERT_AUTHORITY_INVALID] error indicates that the web browser cannot verify the authenticity of a website's SSL/TLS certificate. This typically means the browser does not trust the Certificate Authority (CA) that issued the certificate, or there's an issue with the certificate chain. Usually it can be solved by cleaning the dev-cert and trust it again by running the following commands:
`dotnet dev-cert https --clean`
`dotnet dev-cert https --trust`

HTTP, Observables and RxJS

1. HTTP request, usually from an Angular Service (since they are singeltons)
2. Receive the Observable and cast it into an items array
3. Subscribe to the Observable from a component
4. Assign the items array to a local variable for use in the component's template

RxJS (Reactive Extentions for JavaScript)
- Utility library for working with Observables, similar to lodash or underscore for javascript objects and arrays.
- Uses the <pipe()> method to chain RxJS operators together

ROUTING IN ANGULAR
1) CONFIGURATION - Make sure that in the [app.config.ts] file, the Route is provided (`provideRouter(Route)` in the <providers> array). The app.routes.ts file exports a routes array which is passed to the Angular router (via the providers in the config file)
2) DEFINING ROUTES - Inside the routes array in the app.routes.ts file we are defining all our routes. Each route is an object that contains a path (string which should appear in the url after the baseUrl) and the component that will be displayed when redirecting to the specified path, or another path that is already defined in the routes array. Usually, for the Home component we will redirect to an empty string [''] meaning that if no path is defined after the baseUrl. the application will display the Home component.
3) For dynamic routing we use colons [:] and the parameter. For example, to display a certain product we will define: 
   `{ path: 'shop/:id', component: ProductDetails },`. The id will be the product's id.
4) As a default route we use the wildcard [**]. This means that any path that will be given, that does not match the defined paths will be redirected to the defined address / component defined in the wildcard. We also need to define here a pathMatch property that can accept two options - full or prefix. The default is prefix, meaning that any path that starts with the provided path is Ok. full means that the path must match exactly the provided string. This is important since all paths strat with [''] so we must define it as `pathMatch: full`.
5) PLACING THE ROUTER OUTLET - In the app.ts file we need to add to the providers array the RouteOutlet. This will be used in the app.html template as an element. The application will replace this element in the appropriate component according to the path and component / address provided in the app.route.ts file
6) ADDING ROUTER LINKS - In the elements where we want to click to be redirected to the appropriate component (Menu, Header, Navigation pane, etc.) We need to import the <RouterLink> in the [imports] array (in the ts file of the component). Then, in the template file (html) we need to add an attribute to the element we want to click on to be redirected. The attribute will be the router-link. For example: `<a routerLink="/">Home</a>` which means that clicking on the anchor element that has the Home text  will search a path that contains only the [/] text after the baseUrl and will redirect the user to the defined component
7) DEFINING BEHAVIOR FOR ACTIVE ROUTE - We can set a different visualization when a route is selected. For example, in menues we can define a diffferent look for a selected option. First we need to import the RouterLinkActive to the imports array in the relevant component ts file (the component that contains the buttons / anchors that will be selected) and in the template html file, add to the button. anchor (or any other element) the routerLinkActive attribute (along with the routerLink attribute) and define the desired class that we want to add to the element if it is selected. In the added class we can add the style we want to define once the option is selected
8) When we defined ['/'] in the routerLinkActive it will match to all the paths since they all contain the [/] char. To specify that the link will be active only if it will be exacty with the [/] char and with nothing after it we need to add the following attribute: `[routerLinkActiveOptions]="{ exact: true }"`. This means that only if the url will have the [/] char after the baseUrl and with nothing more, then the link will be considered as active

ERROR HANDLING IN THE CLIENT
Using Interceptors - Interceptors are like middleware that allows us to catch a request before it goes to the server, and catch the response before it is reaches the component
If implementing interceptors they should be added to the provideHttpClient function in the app.config.ts file. In this case this function will get a function - 'withInterceptors()' that receives an array with all the implemented interceptors

ENVIRONMENTS
In order to be able to define environment variables we need to create the environments folder
using a dedicated call -> `ng g environments`. This will create the folder and 2 TS files -> one for the production and one for the development. It will also automatically update the [angular.json] file under the development object and set a replacement file instruction saying to use a [envirnment.development.ts] file if working in <development> mode.

[SignalR]
1) The main idea is when the app is initialized and the user is logged in we will make the connection to the SignalR service on the backend, and we will also create this connection on every user login

[`Preparing the Client for deployment`]
The approach is to host all the client assets (all the javascript, css, and html files) that are created using the build command. The WebServer will be responsible to serve these static assets (including images, icons, etc.) when needed. These files will be in a wwwroot folder in the API folder.
1) Replace all the hardcoded properties such as localhost, in properties from the environment file.
2) In the Angular.json file update under the [options] object that is under the [build] object, the [OutputPath] to `../API/wwwroot`. The OutputPath should look like this:
   `"options": {`
      `"base": "../API/wwwroot",`
      `"browser": ""`
   `}`
   This will put all the static files created from the ng build command under this folder
3) If there are delays in the code that were defined for development needs, either remove it, or set it to be relevant only in development by checking the <environment.production> expression which returns `true` if we are in production, and `false` if we are in development mode. If you need to create an empty function (a function that does nothing) you can use the <identity> which is a function that does nothing (like delay(0)).
4) When running ng build, if you get an error that the file limit was crossed you can change the file limit in the Angular.json file under the [configurations] -> [production] -> [budgets] and change the [maximumError] to a higher value.The ideal is to keep it low for performance.

# Lazy loading
When we run ng build we can see in the `Initial total` line the size of files that the user's brwoser is going to load each time it runs the application. This might be heavy and we could use the Lazy loading approach to define some components that will be load later and not on initiation. For example, in this app - the checkout and order components could be fetched later and not immediatelly on application start. For sure, as an administrator, this data is not required.

## Implementing Lazy loading